<html>
	<head>
		<title>Light Trail</title>
		<style>

		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
	</head>
	<body>

		<script>

			var scene, renderer, camera, stats;

			function Start() {

				// set-up base
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// set-up scena
				cubes = createCubes(11, new THREE.Vector3(-2,2,0));

				stalkers = createMultipleStalkers(cubes, 30);

				// statistiche frame
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

				// set-up camera
				camera.position.z = 5;

			}


			// crea un array di cubi gialli
			function createCubes(index, cubesPos){
				var geometry = new THREE.BoxGeometry(1,1,1);
				var material = new THREE.MeshBasicMaterial( { color: 0xffff00, wireframe:true } );
				var cubes=[];
				for ( i=0; i<index; i++ ){
					cubes[i] = new THREE.Mesh( geometry, material );
					scene.add(cubes[i]);
					var x = cubesPos.x;
					var y = cubesPos.y;
					var z = cubesPos.z;
					cubes[i].position.set(x,y,z);
				}
				return cubes;
			}


			/*
				muove cube sul perimetro del quadrato di lato 4 centrato nell'origine
			*/
			var posX = -2.0;
			var posY = 2.0;
			var direction = 1;
			function moveCube(cube){
				var speed = 0.05;
				if (direction==0){
					if (posX <= 2){
						posX += speed;
					} else if (posY <= 2){
						posY += speed;
					} else {
						direction = 1;
					}
				} else {
					if (posX >= -2){
						posX -= speed;
					} else if (posY >= -2){
						posY -= speed;
					} else {
						direction = 0;
					}
				}
				cube.position.set(posX, posY, 0);
			}




			/**
				DEFINIZIONI:
					- origin: obj indipendente che si muove
					- stalker: array in cui vengono tracciate le ultime n posizioni di un obj origin
					- follower: obj che assume le stesse posizioni di un obj origin con un ritardo di n posizioni
			**/


			/*
		 		crea un array di stalkers
		 		ogni stalker è relativo a un elemento di origins, array di oggetti
		 		delay rappresenta il ritardo con cui ogni follower seguirà il suo origin. Il ritardo è espresso
		 		come numero di posizione passate memorizzate
		 	*/
			function createMultipleStalkers(origins, delay){
				var stalkers=[];
				for (var i = 0; i < origins.length-1; i++){
					stalkers[i] = createStalker(origins[i], delay);
				}
				return stalkers;
			}


			/*
				crea un array stalker di origin
				lo stalker appena creato avrà tutte le sue posizioni uguali pari alla posizione iniziale di origin
				questo permette il ritardo	voluto nel tracciare le posizioni di origin
			*/
			function createStalker(origin, delay){
				var stalker = [];
				for(var i = 0; i < delay; i++) {
				    stalker.push(origin.position.clone());
				}
				return stalker;
			}


			/*
				inserisce in coda all'array stalker la posizione attuale di origin
				rimuove la posizione in tesa
			*/
			function updateStalker(origin, stalker){
				stalker.shift();
				stalker.push(origin.position.clone());
			}


			/*
				muove tutti i follower in origins
			*/
			function moveMultipleFollowers(origins, stalkers){
				for (var i=0; i<origins.length-1; i++){
					moveFollower(origins[i], stalkers[i], origins[i+1]);
				}
			}

			/*
				esegue un passo del follower
			*/
			function moveFollower(origin, stalker, follower){
				var x = stalker[0].x;
				var y = stalker[0].y;
				var z = stalker[0].z;
				follower.position.set(x,y,z);
				updateStalker(origin, stalker);
			}

			function Render() {

				requestAnimationFrame(Render);
				stats.update();
				moveCube(cubes[0]);
				moveMultipleFollowers(cubes, stalkers);
				renderer.render(scene, camera);
			}

			Start();
			Render();

		</script>
	</body>
</html>
