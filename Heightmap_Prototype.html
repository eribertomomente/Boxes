<html>
	<head>
		<title>Starting Code for 1st Project 2017</title>
		<style>

		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="obj/Arena.js"></script>
		<script src="obj/SnakeGame.js"></script>
		<script src="obj/Snake.js"></script>
		<script src="config.js"></script>

		<link rel="icon" href="favicon.ico">

	</head>
	<body>

		<script>

		var scene, camera, renderer, controls, stats;

		//return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		function getHeightData(img,scale) {

			if (scale == undefined) scale=1;

		    var canvas = document.createElement( 'canvas' );
		    canvas.width = img.width;
		    canvas.height = img.height;
		    var context = canvas.getContext( '2d' );

		    var size = img.width * img.height;
			console.log(size);
		    var data = new Float32Array( size );

		    context.drawImage(img,0,0);

		    for ( var i = 0; i < size; i ++ ) {
		        data[i] = 0
		    }

		    var imgd = context.getImageData(0, 0, img.width, img.height);
		    var pix = imgd.data;

		    var j=0;
		    for (var i = 0; i<pix.length; i +=4) {
		        var all = pix[i]+pix[i+1]+pix[i+2];  // all is in range 0 - 255*3
		        data[j++] = scale*all/3;
		    }

		    return data;
		}

		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000 );
			document.body.appendChild( renderer.domElement );

			camera.position.set(-5,20,45);
			camera.lookAt( new THREE.Vector3(0,0,0));

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			//mause controls
			controls = new THREE.OrbitControls( camera );
			controls.enableKeys = false;
			controls.addEventListener( 'change', Render );

			// le quattro frecce
			this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

			// gestisco l'evento di pressione di un tasto
			window.addEventListener( 'keydown', onKeyDown, false );

			// terrain
			var img = new Image();
			img.onload = function () {

				//get height data from img
				var data = getHeightData(img,0.1);
				// disegna tutti i cubi presenti in data usando i colori di img
				drawCubes(data, img);

			}
			// load img source
			img.src = "images/machu_picchu5.jpg";

			// set-up scena
			game = new SnakeGame();

			game.snakegame.scale.set(0.2,0.2,0.2);
			game.snakegame.position.set(5,25,1);
		}

		/*
			gestisce la pressione di un qualsiasi tasto
		*/
		function onKeyDown( event ) {

			switch ( event.keyCode ) {
				case keys.RIGHT:
						//console.log("dx")
						game.direction = (game.direction != 2) ? 0 : 2;	// cambio direzione solo se non sto andando nella direzione opposta
					break;

				case keys.UP:
						//console.log("su")
						game.direction = (game.direction != 3) ? 1 : 3;	// cambio direzione solo se non sto andando nella direzione opposta
					break;

				case keys.LEFT:
						//console.log("sx")
						game.direction = (game.direction != 0) ? 2 : 0;	// cambio direzione solo se non sto andando nella direzione opposta
					break;

				case keys.BOTTOM:
						//console.log("giu")
						game.direction = (game.direction != 1) ? 3 : 1;	// cambio direzione solo se non sto andando nella direzione opposta
					break;
			}
		}

		function drawCubes(d, img){

			// viene usata una sola geometria per disegnare tutti i cubi
			var geometry = new THREE.BoxGeometry(1,1,1);

			// array di materiali utilizzati
			grey_materials = [];
			green_materials = [];
			blue_materials = [];
			for(var i=0; i<d.length; i++){

				// colore del pixel(0 - 255) in considerazione
				var pColor = Math.trunc(d[i]*10);

				if (d[i]<6){ /****************** BLUE ******************/

					var hsbColor = Math.round(pColor/255*100)+25;

					var exist = _check_color_material(blue_materials, hsbColor);

					// se non esiste lo creo e lo aggiungo all'array di materiali
					if(exist == -1){
						exist = blue_materials.length;
						blue_materials[exist] = new THREE.MeshBasicMaterial( {color: "hsl(" + 200 + ", " + 65+"%, " + hsbColor + "%)",transparent: true, opacity: 0.7});	// materiale di colore uguale al pixel dell'immagine
					}
					var mat = blue_materials[exist];

				} else if (d[i]<12){ /****************** GREEN ******************/

					var hsbColor = Math.round(pColor/255*100);
					var BColor = (100-hsbColor)-30; // hsB
					var SColor = hsbColor+20; // hSb

					var exist = _check_color_material(green_materials, BColor);

					// se non esiste lo creo e lo aggiungo all'array di materiali
					if(exist == -1){
						exist = green_materials.length;
						green_materials[exist] = new THREE.MeshBasicMaterial( {color: "hsl(" + 120 + ", " + SColor +"%, " + BColor + "%)" } );	// materiale di colore uguale al pixel dell'immagine
					}
					var mat = green_materials[exist];

				} else { /****************** GREY ******************/
					// aggiusto l'intensita' per rendere un effetto visivo migliore
					pColor -=25;

					var exist = _check_color_material(grey_materials, pColor);

					// se non esiste lo creo e lo aggiungo all'array di materiali
					if(exist == -1){
						exist = grey_materials.length;
						grey_materials[exist] = new THREE.MeshBasicMaterial( {color: "rgb(" + pColor + ", " + pColor + ", " + pColor + ")" } );	// materiale di colore uguale al pixel dell'immagine
					}
					var mat = grey_materials[exist];
				}

				var cube = new THREE.Mesh( geometry, mat );

				// imposto la posizione del cubo rispettando l'immagine originale
				cube.position.set(i%img.width - img.width/2, d[i]/2, Math.trunc(i/img.height) - img.height/2);
				// il cubo viene scalato in base al colore (0 basso - 25.5 alto)
				cube.scale.y = d[i];

				scene.add( cube );

			}

		}

		// controlla se esiste giÃ  un materiale in "materials" con colore == "colorValue"
		function _check_color_material(materials, colorValue){
			for(var j=0; j<materials.length; j++){
				if(Math.trunc(materials[j].color.r * 255) == colorValue){
					return j;
				}
			}
			return -1;
		}

		function Update() {
			requestAnimationFrame( Update );

			game.move();

			controls.update();
			stats.update();
			Render();
		}

		function Render() {
			renderer.render(scene, camera);
		}

		Start();
		Update();

		</script>
	</body>
</html>
